/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmy_lms_aish"] = self["webpackChunkmy_lms_aish"] || []).push([
  ["node_modules_opentelemetry-instrumentation-fetch-node_build_index_js"],
  {
    /***/ "./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js":
      /*!******************************************************************************!*\
  !*** ./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js ***!
  \******************************************************************************/
      /***/ function () {
        "use strict";
        eval(
          "\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchInstrumentation = void 0;\n/*\n * Portions from https://github.com/elastic/apm-agent-nodejs\n * Copyright Elasticsearch B.V. and other contributors where applicable.\n * Licensed under the BSD 2-Clause License; you may not use this file except in\n * compliance with the BSD 2-Clause License.\n *\n */\nconst node_diagnostics_channel_1 = __importDefault(__webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\"));\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"./node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"./node_modules/@opentelemetry/api/build/esm/index.js\");\nfunction getMessage(error) {\n    if (error instanceof AggregateError) {\n        return error.errors.map((e) => e.message).join(', ');\n    }\n    return error.message;\n}\n// Get the content-length from undici response headers.\n// `headers` is an Array of buffers: [k, v, k, v, ...].\n// If the header is not present, or has an invalid value, this returns null.\nfunction contentLengthFromResponseHeaders(headers) {\n    const name = 'content-length';\n    for (let i = 0; i < headers.length; i += 2) {\n        const k = headers[i];\n        if (k.length === name.length && k.toString().toLowerCase() === name) {\n            const v = Number(headers[i + 1]);\n            if (!Number.isNaN(Number(v))) {\n                return v;\n            }\n            return undefined;\n        }\n    }\n    return undefined;\n}\nasync function loadFetch() {\n    try {\n        await fetch('');\n    }\n    catch (_) {\n        //\n    }\n}\n// A combination of https://github.com/elastic/apm-agent-nodejs and\n// https://github.com/gadget-inc/opentelemetry-instrumentations/blob/main/packages/opentelemetry-instrumentation-undici/src/index.ts\nclass FetchInstrumentation {\n    // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for\n    // unsubscribing.\n    channelSubs;\n    spanFromReq = new WeakMap();\n    tracer;\n    config;\n    meter;\n    instrumentationName = 'opentelemetry-instrumentation-node-18-fetch';\n    instrumentationVersion = '1.0.0';\n    instrumentationDescription = 'Instrumentation for Node 18 fetch via diagnostics_channel';\n    subscribeToChannel(diagnosticChannel, onMessage) {\n        const channel = node_diagnostics_channel_1.default.channel(diagnosticChannel);\n        channel.subscribe(onMessage);\n        this.channelSubs.push({\n            name: diagnosticChannel,\n            channel,\n            onMessage,\n        });\n    }\n    constructor(config) {\n        // Force load fetch API (since it's lazy loaded in Node 18)\n        loadFetch();\n        this.channelSubs = [];\n        this.meter = api_1.metrics.getMeter(this.instrumentationName, this.instrumentationVersion);\n        this.tracer = api_1.trace.getTracer(this.instrumentationName, this.instrumentationVersion);\n        this.config = { ...config };\n    }\n    disable() {\n        this.channelSubs?.forEach((sub) => sub.channel.unsubscribe(sub.onMessage));\n    }\n    enable() {\n        this.subscribeToChannel('undici:request:create', (args) => this.onRequest(args));\n        this.subscribeToChannel('undici:request:headers', (args) => this.onHeaders(args));\n        this.subscribeToChannel('undici:request:trailers', (args) => this.onDone(args));\n        this.subscribeToChannel('undici:request:error', (args) => this.onError(args));\n    }\n    setTracerProvider(tracerProvider) {\n        this.tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);\n    }\n    setMeterProvider(meterProvider) {\n        this.meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);\n    }\n    setConfig(config) {\n        this.config = { ...config };\n    }\n    getConfig() {\n        return this.config;\n    }\n    onRequest({ request }) {\n        // Don't instrument CONNECT - see comments at:\n        // https://github.com/elastic/apm-agent-nodejs/blob/c55b1d8c32b2574362fc24d81b8e173ce2f75257/lib/instrumentation/modules/undici.js#L24\n        if (request.method === 'CONNECT') {\n            return;\n        }\n        if (this.config.ignoreRequestHook && this.config.ignoreRequestHook(request) === true) {\n            return;\n        }\n        const span = this.tracer.startSpan(`HTTP ${request.method}`, {\n            kind: api_1.SpanKind.CLIENT,\n            attributes: {\n                [semantic_conventions_1.SemanticAttributes.HTTP_URL]: getAbsoluteUrl(request.origin, request.path),\n                [semantic_conventions_1.SemanticAttributes.HTTP_METHOD]: request.method,\n                [semantic_conventions_1.SemanticAttributes.HTTP_TARGET]: request.path,\n                'http.client': 'fetch',\n            },\n        });\n        const requestContext = api_1.trace.setSpan(api_1.context.active(), span);\n        const addedHeaders = {};\n        api_1.propagation.inject(requestContext, addedHeaders);\n        if (this.config.onRequest) {\n            this.config.onRequest({ request, span, additionalHeaders: addedHeaders });\n        }\n        if (Array.isArray(request.headers)) {\n            request.headers.push(...Object.entries(addedHeaders).flat());\n        }\n        else {\n            request.headers += Object.entries(addedHeaders)\n                .map(([k, v]) => `${k}: ${v}\\r\\n`)\n                .join('');\n        }\n        this.spanFromReq.set(request, span);\n    }\n    onHeaders({ request, response }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            // We are currently *not* capturing response headers, even though the\n            // intake API does allow it, because none of the other `setHttpContext`\n            // uses currently do.\n            const cLen = contentLengthFromResponseHeaders(response.headers);\n            const attrs = {\n                [semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE]: response.statusCode,\n            };\n            if (cLen) {\n                attrs[semantic_conventions_1.SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH] = cLen;\n            }\n            span.setAttributes(attrs);\n            span.setStatus({\n                code: response.statusCode >= 400 ? api_1.SpanStatusCode.ERROR : api_1.SpanStatusCode.OK,\n                message: String(response.statusCode),\n            });\n        }\n    }\n    onDone({ request }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            span.end();\n            this.spanFromReq.delete(request);\n        }\n    }\n    onError({ request, error }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            span.recordException(error);\n            span.setStatus({\n                code: api_1.SpanStatusCode.ERROR,\n                message: getMessage(error),\n            });\n            span.end();\n        }\n    }\n}\nexports.FetchInstrumentation = FetchInstrumentation;\nfunction getAbsoluteUrl(origin, path = '/') {\n    const url = `${origin}`;\n    if (origin.endsWith('/') && path.startsWith('/')) {\n        return `${url}${path.slice(1)}`;\n    }\n    if (!origin.endsWith('/') && !path.startsWith('/')) {\n        return `${url}/${path.slice(1)}`;\n    }\n    return `${url}${path}`;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://my_lms_aish/./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js?",
        );

        /***/
      },

    /***/ "node:diagnostics_channel":
      /*!********************************!*\
  !*** node:diagnostics_channel ***!
  \********************************/
      /***/ () => {
        eval(
          'throw new Error("Module build failed: UnhandledSchemeError: Reading from \\"node:diagnostics_channel\\" is not handled by plugins (Unhandled scheme).\\nWebpack supports \\"data:\\" and \\"file:\\" URIs by default.\\nYou may need an additional plugin to handle \\"node:\\" URIs.\\n    at D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\webpack\\\\lib\\\\NormalModule.js:973:10\\n    at Hook.eval [as callAsync] (eval at create (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\tapable\\\\lib\\\\HookCodeFactory.js:33:10), <anonymous>:6:1)\\n    at Object.processResource (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\webpack\\\\lib\\\\NormalModule.js:969:8)\\n    at processResource (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\loader-runner\\\\lib\\\\LoaderRunner.js:220:11)\\n    at iteratePitchingLoaders (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\loader-runner\\\\lib\\\\LoaderRunner.js:171:10)\\n    at runLoaders (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\loader-runner\\\\lib\\\\LoaderRunner.js:398:2)\\n    at NormalModule._doBuild (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\webpack\\\\lib\\\\NormalModule.js:959:3)\\n    at NormalModule.build (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\webpack\\\\lib\\\\NormalModule.js:1144:15)\\n    at D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\webpack\\\\lib\\\\Compilation.js:1418:12\\n    at NormalModule.needBuild (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\webpack\\\\lib\\\\NormalModule.js:1466:32)\\n    at Compilation._buildModule (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\webpack\\\\lib\\\\Compilation.js:1399:10)\\n    at D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\webpack\\\\lib\\\\util\\\\AsyncQueue.js:324:10\\n    at Hook.eval [as callAsync] (eval at create (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\tapable\\\\lib\\\\HookCodeFactory.js:33:10), <anonymous>:6:1)\\n    at AsyncQueue._startProcessing (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\webpack\\\\lib\\\\util\\\\AsyncQueue.js:314:26)\\n    at AsyncQueue._ensureProcessing (D:\\\\college\\\\pupilsfirst\\\\lms capstone\\\\node_modules\\\\webpack\\\\lib\\\\util\\\\AsyncQueue.js:301:12)\\n    at process.processImmediate (node:internal/timers:478:21)");\n\n//# sourceURL=webpack://my_lms_aish/node:diagnostics_channel?',
        );

        /***/
      },
  },
]);
